<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <title>Project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden
        }

        canvas {
            display: block
        }
        /* Style for the button to make it visible and usable */
        #scene-toggle-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            font-size: 16px;
            z-index: 100; /* Ensure it's above the canvas */
            cursor: pointer;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    
</head>

<body>
    <button id="scene-toggle-button">Toggle Scene: Star Sky</button>
    <script>
        (() => {
            
            // --- Scene / Camera / Renderer ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
            camera.position.set(0, 2, 3);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(3, 1, 1.2 );
            controls.enableDamping = true;

            //light
            const directionalLight = new THREE.DirectionalLight(0xff0000, 0.7);
            directionalLight.position.set(6, 5, 0);
            directionalLight.castShadow = true;
            
            scene.add(directionalLight);

            //const helper = new THREE.DirectionalLightHelper(directionalLight, 1);
            //scene.add(helper);

            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;  

            directionalLight.shadow.bias = -0.0005; // ค่าลบเล็กน้อย
            directionalLight.shadow.normalBias = 0.05; // ค่าบวกเล็กน้อย

            const pointlight = new THREE.PointLight(0x0000ff, 1);
            pointlight.position.set(2.5, 2.5, -3);
            pointlight.castShadow = true;
            scene.add(pointlight);

            //const pointlightHelper = new THREE.PointLightHelper(pointlight, 0.5);
            //scene.add(pointlightHelper);

            pointlight.shadow.mapSize.width = 1024;
            pointlight.shadow.mapSize.height = 1024;

            pointlight.shadow.bias = -0.0005; // ค่าลบเล็กน้อย
            pointlight.shadow.normalBias = 0.05; // ค่าบวกเล็กน้อย

            const pointlight2 = new THREE.PointLight(0x7700ff, 1 , 10, 2);
            pointlight2.position.set(-2.5, 2, -2.5);
            pointlight2.castShadow = true;
            scene.add(pointlight2);

            //const pointlightHelper2 = new THREE.PointLightHelper(pointlight2, 0.5);
            //scene.add(pointlightHelper2);

            pointlight2.shadow.mapSize.width = 1024;
            pointlight2.shadow.mapSize.height = 1024;

            pointlight2.shadow.bias = -0.0005; // ค่าลบเล็กน้อย
            pointlight2.shadow.normalBias = 0.05; // ค่าบวกเล็กน้อย

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            

            // Load two HDR environments and set up toggle
            let envMapDay = null;
            let envMapNight = null;
            let isNight = false;
            // Load day environment
            new THREE.RGBELoader().setDataType(THREE.UnsignedByteType).load('https://touchzaza1111.github.io/FInalAs/rogland_overcast_1k.hdr', function(texture) {
                envMapDay = texture;
                envMapDay.mapping = THREE.EquirectangularReflectionMapping;
                if (!isNight) {
                    scene.environment = envMapDay;
                    scene.background = envMapDay;
                }
            });
            // Load night environment
            new THREE.RGBELoader().setDataType(THREE.UnsignedByteType).load('https://touchzaza1111.github.io/FInalAs/rogland_clear_night_1k.hdr', function(texture) {
                envMapNight = texture;
                envMapNight.mapping = THREE.EquirectangularReflectionMapping;
                if (isNight) {
                    scene.environment = envMapNight;
                    scene.background = envMapNight;
                }
            });

            let isStarryNight = false; // State variable for the scene

            // HDR URLs
            const hdrOvercastUrl = 'https://touchzaza1111.github.io/FInalAs/rogland_overcast_1k.hdr';
            const hdrClearNightUrl = 'https://touchzaza1111.github.io/FInalAs/rogland_clear_night_1k.hdr';
            let hdrOvercast = null;
            let hdrClearNight = null;

            const button = document.getElementById('scene-toggle-button');

            function toggleSceneBackground() {
                isNight = !isNight;
                if (isNight) {
                    if (envMapNight) {
                        scene.environment = envMapNight;
                        scene.background = envMapNight;
                    }
                    button.textContent = 'Toggle Scene: Blue Sky';
                } else {
                    if (envMapDay) {
                        scene.environment = envMapDay;
                        scene.background = envMapDay;
                    }
                    button.textContent = 'Toggle Scene: Star Sky';
                }
            }

            // --- Load Models ---
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load(
                'https://touchzaza1111.github.io/FInalAs/room.glb',
                (gltf) => {
                    const model = gltf.scene || gltf.scenes[0];
                    model.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    model.position.set(0, 0, 0);
                    //model.scale.set(0.1, 0.1, 0.1);
                    scene.add(model);
                },
                undefined,
                (error) => {
                    console.error('Error loading glTF:', error);
                }
            );

            
            const gltfLoader2 = new THREE.GLTFLoader();
            gltfLoader2.load(
                'https://touchzaza1111.github.io/FInalAs/arcane_vi_gauntlet_fanart.glb',
                (gltf) => {
                    const model = gltf.scene || gltf.scenes[0];
                    model.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    model.position.set(-0.3, 0.91, 0.3);
                    model.rotation.set(Math.PI / 2.5, 0, 0);
                    scene.add(model);
                },
                undefined,
                (error) => {
                    console.error('Error loading glTF:', error);
                }
            );
            
            
            const vert = `
            uniform float uTime;
            varying vec3 vNormal;
            varying vec3 vPosW;
            varying vec2 vUv;

            void main(){
                vNormal = normalize(mat3(modelMatrix) * normal);
                vec3 pos = position;
                vPosW   = ( modelMatrix * vec4(pos, 1.0)).xyz;
                vUv     = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
            `;

            const frag = `
            uniform vec3 uLightDir1;
            uniform vec3 uLightColor1;
            uniform vec3 uLightDir2;
            uniform vec3 uLightColor2;
            uniform sampler2D uMap;
            varying vec3 vNormal;
            varying vec3 vPosW;
            varying vec2 vUv;

            void main()
            {
                vec4 texel = texture2D(uMap, vUv);

                // Light 1
                float diffuse1 = max(dot(vNormal, uLightDir1), 0.0);
                float levels = 4.0;
                diffuse1 = floor(diffuse1 * levels) / levels;
                vec3 R1 = reflect(-uLightDir1, vNormal);
                vec3 V = normalize(cameraPosition - vPosW);
                float specular1 = max(pow(dot(R1, V), 64.0), 0.0);
                specular1 = step(0.5, specular1);
                specular1 *= diffuse1;

                // Light 2
                float diffuse2 = max(dot(vNormal, uLightDir2), 0.0);
                diffuse2 = floor(diffuse2 * levels) / levels;
                vec3 R2 = reflect(-uLightDir2, vNormal);
                float specular2 = max(pow(dot(R2, V), 64.0), 0.0);
                specular2 = step(0.5, specular2);
                specular2 *= diffuse2;

                vec3 base = texel.rgb;
                vec3 color = (base * (uLightColor1 * diffuse1 + uLightColor2 * diffuse2)) + vec3(specular1 + specular2);
                gl_FragColor = vec4(color, 1.0);
            }
            `;
            
            const material = new THREE.ShaderMaterial({
                vertexShader: vert,
                fragmentShader: frag,
                uniforms: {
                    uTime: { value: 0 },
                    uLightDir1: { value: new THREE.Vector3(-4, 3, 0.8).normalize() },
                    uLightColor1: { value: new THREE.Color(0xFF8888) },
                    uLightDir2: { value: pointlight.position.clone().normalize() },
                    uLightColor2: { value: new THREE.Color(0x0000ff) },
                    uMap: { value: new THREE.TextureLoader().load('https://touchzaza1111.github.io/FInalAs/12_meshes_Merge_Diffuse2.png') }
                }
            });

            const objLoader = new THREE.OBJLoader();
            objLoader.load(
                'https://touchzaza1111.github.io/FInalAs/Jinx.obj',
                (obj) => {
                    obj.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            node.material = material;
                        }
                    });
                    obj.position.set(3, 0, 1.2);
                    obj.scale.set(1.5, 1.5, 1.5);
                    obj.rotation.set(0, -Math.PI / 2, 0);
                    scene.add(obj);
                },
                undefined,
                (error) => {
                    console.error('Error loading Object:', error);
                }
            );
            
            // --- uniforms (เพิ่ม uTime) ---
            const uniforms = { uTime: { value: 0.0 } };

            const vert2 = `
                uniform float uTime;
                void main(){
                float PI = 3.141592653589793;
                vec3 pos = position;
                
                //ลองใช้วิธีปรับตำแหน่งแกน z 
                //pos.z = cos(pos.y + uTime) * 0.1; // ปรับความสูงได้ด้วยการคูณ factor
                
                //ทดลองใช้วิธีปรับตำแหน่งจาก Normal 
                vec3 N = normalize(normal); 
                pos += N * (sin(pos.x + uTime) * 0.1) + N * (cos(pos.y + uTime) * 0.01); // ปรับความสูงได้ด้วยการคูณ factor

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const frag2 = `
                precision mediump float;
                void main(){ gl_FragColor = vec4(0.5, 0.0, 1.0, 1.0); }
            `;

            const vert3 = `
                uniform float uTime;
                void main(){
                float PI = 3.141592653589793;
                vec3 pos = position;
                
                //ลองใช้วิธีปรับตำแหน่งแกน z 
                //pos.z = cos(pos.y + uTime) * 0.1; // ปรับความสูงได้ด้วยการคูณ factor
                
                //ทดลองใช้วิธีปรับตำแหน่งจาก Normal 
                vec3 N = normalize(normal); 
                pos += N * (sin(pos.x + uTime) * 0.1) + N * (cos(pos.y + uTime) * 0.01); // ปรับความสูงได้ด้วยการคูณ factor

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const frag3 = `
                precision mediump float;
                void main(){ gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); }
            `;

            const geo = new THREE.SphereBufferGeometry(0.4, 20, 20);
            const mat = new THREE.ShaderMaterial({
                vertexShader: vert2,
                fragmentShader: frag2,
                uniforms,
                side: THREE.DoubleSide,
                //wireframe: true
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(-2.5, 2, -2.5);
            scene.add(mesh);

            const objLoader4 = new THREE.OBJLoader();
            objLoader4.load(
                'https://touchzaza1111.github.io/FInalAs/Untitled.obj',
                (obj) => {
                    obj.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            node.material = new THREE.ShaderMaterial({
                                vertexShader: vert3,
                                fragmentShader: frag3,
                                uniforms,
                                side: THREE.DoubleSide,
                            });
                        }
                    });
                    obj.position.set(-2.5, 2, -2.5);
                    obj.scale.set(0.5, 0.5, 0.5);
                    scene.add(obj);
                },
                undefined,
                (error) => {
                    console.error('Error loading Object:', error);
                }
            );
            
            const DEG2RAD = Math.PI / 180;
            const objLoader1 = new THREE.OBJLoader();
            objLoader1.load(
                'https://touchzaza1111.github.io/FInalAs/Miniarcanetxt.obj',
                (obj) => {
                    obj.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            node.material = defaultMaterial = new THREE.MeshPhongMaterial({
                                color: 0xffffff,
                            });
                        }
                    });
                    obj.position.set(2, 1.6, 2);
                    obj.scale.set(0.4, 0.4, 0.4);
                    obj.rotation.set(90 * DEG2RAD, 0 * DEG2RAD, 45);
                    scene.add(obj);
                },
                undefined,
                (error) => {
                    console.error('Error loading Object:', error);
                }
            );

            const objLoader2 = new THREE.OBJLoader();
            objLoader2.load(
                'https://touchzaza1111.github.io/FInalAs/yogdy_jinxrtxt.obj',
                (obj) => {
                    obj.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            node.material = defaultMaterial = new THREE.MeshPhongMaterial({
                                color: 0xffffff,
                            });
                        }
                    });
                    obj.position.set(0, 3, -4.5);
                    obj.scale.set(0.4, 0.4, 0.4);
                    obj.rotation.set(90 * DEG2RAD, 0 * DEG2RAD, 90 * DEG2RAD);
                    scene.add(obj);
                },
                undefined,
                (error) => {
                    console.error('Error loading Object:', error);
                }
            );

            const objLoader3 = new THREE.OBJLoader();
            objLoader3.load(
                'https://touchzaza1111.github.io/FInalAs/postias_ViGlovetxt.obj',
                (obj) => {
                    obj.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            node.material = defaultMaterial = new THREE.MeshPhongMaterial({
                                color: 0xffffff,
                            });
                        }
                    });
                    obj.position.set(-0.5, 3, 0);
                    obj.scale.set(0.4, 0.4, 0.4);
                    obj.rotation.set(90 * DEG2RAD, 0 * DEG2RAD, 180 * DEG2RAD);
                    scene.add(obj);
                },
                undefined,
                (error) => {
                    console.error('Error loading Object:', error);
                }
            );

            const txtLoader = new THREE.TextureLoader();
            const texture = txtLoader.load('https://touchzaza1111.github.io/FInalAs/1760692191526.jpg');
            const geo2 = new THREE.PlaneBufferGeometry(0.6, 0.8);
            const mat2 = new THREE.MeshBasicMaterial({
                castShadow: true,
                receiveShadow: true,
                map: texture
            });
            const mesh2 = new THREE.Mesh(geo2, mat2);
            mesh2.position.set(-1.3, 3.27, 1.2);
            mesh2.rotation.set(0 * DEG2RAD, 30 * DEG2RAD, 0);
            scene.add(mesh2);

            const clickable = []; // Array to store clickable objects
            function loadObj(objUrl, color, pos, rotation = new THREE.Vector3(0, 0, 0) , scale = new THREE.Vector3(0, 0, 0), name) {
                objLoader.load(
                    objUrl,
                    (model) => {
                        // Create a default material
                        const defaultMaterial = new THREE.MeshPhongMaterial({
                            color: color,
                        });

                        // Iterate through all children (meshes) and apply the default material
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.material = defaultMaterial;
                            }
                        });

                        // Create a container to apply the final position and scale
                        const pivot = new THREE.Group();
                        pivot.add(model);

                        // Set final properties
                        pivot.position.copy(pos);
                        pivot.rotation.set(rotation.x, rotation.y, rotation.z);
                        pivot.name = name;
                        pivot.scale.copy(scale);
                        // Scale the model (adjust as necessary)
                       

                        scene.add(pivot);
                        clickable.push(pivot);

                        console.log(`Loaded ${name} from ${objUrl} with default material.`);
                    },  
                    (error) => {
                        console.error(`An error happened loading OBJ ${objUrl}:`, error);
                    }
                );
            }
            

            // --- Load Objects from GitHub ---
            // NOTE: Replace the URLs below with the RAW links to your .obj models on GitHub.
            const BASE_URL = 'https://touchzaza1111.github.io/FInalAs/';
            loadObj(
                BASE_URL + 'AboutMetxt.obj', // Replace with your OBJ filename
                new THREE.Color(0xffffff), // White color
                new THREE.Vector3(2, 1.3, 2),
                new THREE.Vector3(90 * DEG2RAD, 0 * DEG2RAD, 45),
                new THREE.Vector3(0.3, 0.3, 0.3),
                'ObjectA'
            );

            loadObj(
                BASE_URL + 'Credittxt.obj',
                new THREE.Color(0xffffff), // Green color
                new THREE.Vector3(2, 1, 2),
                new THREE.Vector3(90 * DEG2RAD, 0 * DEG2RAD, 45),
                new THREE.Vector3(0.2, 0.2, 0.2),
                'ObjectB'
            );

            loadObj(
                BASE_URL + 'Backtxt.obj',
                new THREE.Color(0xffffff), // Blue color
                new THREE.Vector3(-0.5, 2.5, 1),
                new THREE.Vector3(90 * DEG2RAD, 0 * DEG2RAD, -30 * DEG2RAD), // ROTATION: 15° X, 45° Y
                new THREE.Vector3(0.3, 0.3, 0.3),
                'ObjectC'
            );

            loadObj(
                BASE_URL + 'Backtxt.obj',
                new THREE.Color(0xffffff), // Blue color
                new THREE.Vector3(-4, 2, -2),
                new THREE.Vector3(-90 * DEG2RAD, 180 * DEG2RAD, 0), // ROTATION: 15° X, 45° Y
                new THREE.Vector3(0.5, 0.5, 0.5),
                'ObjectD'
            );


            // --- พรีเซ็ตตำแหน่งกล้องต่อวัตถุ (กำหนดง่าย ๆ) ---
            const VIEWS = {
                ObjectA: {
                    pos: new THREE.Vector3( 0, 3.5, 3.4),
                    tar: new THREE.Vector3(-2, 2, 0)
                },
                ObjectB: {
                    pos: new THREE.Vector3(-5, 3, -5),
                    tar: new THREE.Vector3(0, 0.5, 0)
                },
                ObjectC: {
                    pos: new THREE.Vector3(0, 2, 3),
                    tar: new THREE.Vector3(3, 1, 1.2)
                },
                ObjectD: {
                    pos: new THREE.Vector3(0, 2, 3),
                    tar: new THREE.Vector3(3, 1, 1.2)
                }
            };

            // --- Raycaster + คลิกเพื่อสลับมุม ---
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();

            function setPointer(e) {
                const r = renderer.domElement.getBoundingClientRect();
                const x = (e.clientX ?? e.touches[0].clientX) - r.left;
                const y = (e.clientY ?? e.touches[0].clientY) - r.top;
                pointer.x = (x / r.width) * 2 - 1;
                pointer.y = -(y / r.height) * 2 + 1;
            }
            
            function onPick(e) {
                setPointer(e);
                raycaster.setFromCamera(pointer, camera);
                const hit = raycaster.intersectObjects(clickable, true)[0];

                if (!hit) return;
                
                // Find the top-level clickable object (the pivot/group)
                let pickedObject = hit.object;
                while (pickedObject.parent && pickedObject.parent !== scene) {
                    pickedObject = pickedObject.parent;
                    if (pickedObject.name in VIEWS) break; // Found the top-level named group
                }

                if (!pickedObject || !pickedObject.name) return;

                const view = VIEWS[pickedObject.name];
                if (!view) return;
                
                camera.position.copy(view.pos);
                controls.target.copy(view.tar);
                controls.update();
            }

            function lerp(a, b, t) {
                return a + (b - a) * t;   // t ใน [0..1]
            }

            renderer.domElement.addEventListener('click', onPick);
            renderer.domElement.addEventListener('touchstart', (e) => {
                onPick(e);
            }, {
                passive: true
            });

           
            
            button.addEventListener('click', toggleSceneBackground);
            button.addEventListener('touchstart', (e) => { toggleSceneBackground(); }, { passive: true });
            
            
            // --- Resize ---
            addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });

            let envRotation = 0;
            // --- Loop ---
            function loop() {
                uniforms.uTime.value += 0.01;

                const bg = scene.background;
                if (bg && bg.isTexture) {
                    envRotation += 0.002; // Adjust speed as needed
                    bg.mapping = THREE.EquirectangularReflectionMapping;
                    bg.center = new THREE.Vector2(0.5, 0.5);
                    bg.rotation = envRotation;
                    bg.needsUpdate = true;
                }

                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }
            loop();
        })();
    </script>
</body>

</html>
